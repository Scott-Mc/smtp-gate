#!/usr/bin/env bash
# smtp-gate -- block outbound SMTP from VM guests at the hypervisor
set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "$(readlink -f "$0")")" && pwd)"
CONF_DIR="$SCRIPT_DIR/config"
CONF_FILE="$CONF_DIR/smtp-gate.conf"
WL_FILE="$CONF_DIR/whitelist.csv"

TABLE="smtp_gate"
CHAIN="egress"
SET_WL="wl_macs"
SET_PORTS="blocked_ports"
SET_VMPORTS="vm_ports"
SET_UPLINKS="uplinks"

require_root() { [[ "${EUID}" -eq 0 ]] || { echo "error: run as root" >&2; exit 1; }; }
have_cmd()     { command -v "$1" >/dev/null 2>&1; }

load_conf() {
  BRIDGE="br0"
  BLOCKED_PORTS="25,465"
  LOG_DROPS="1"
  LOG_RATE="5/second"
  LOG_BURST="50"
  [[ -f "$CONF_FILE" ]] && source "$CONF_FILE"
}

ensure_dirs() {
  mkdir -p "$CONF_DIR"
  [[ -f "$WL_FILE" ]] || printf "# vmname,mac,added_at,added_by,reason\n" > "$WL_FILE"
}

# ---------------------------------------------------------------------------
# Bridge / port discovery
# ---------------------------------------------------------------------------

bridge_ports() {
  bridge link | awk -v br="$BRIDGE" '$0 ~ ("master " br) {print $2}' | sed 's/://'
}

uplink_ports() {
  local re="${UPLINK_REGEX:-^(ens|eno|enp|eth|bond)[0-9a-zA-Z_.:-]*$}"
  bridge_ports | awk -v re="$re" '$0 ~ re'
}

vm_ports() {
  local upl
  upl="$(uplink_ports | tr '\n' ' ' | xargs || true)"
  bridge_ports | while read -r p; do
    [[ -n "$p" ]] || continue
    [[ "$p" == "$BRIDGE" ]] && continue
    echo " $upl " | grep -q " $p " && continue
    echo "$p"
  done
}

parse_ports() { echo "$BLOCKED_PORTS" | tr ',' ' ' | xargs -n1; }

# ---------------------------------------------------------------------------
# Hypervisor driver loading
# ---------------------------------------------------------------------------

HV_LOADED=""

load_driver() {
  local name="$1"
  local drv="$SCRIPT_DIR/drivers/${name}.sh"
  [[ -f "$drv" ]] || { echo "error: driver '$name' not found ($drv)" >&2; return 1; }
  source "$drv"
  hv_list_vms() { driver_list_vms "$@"; }
  hv_vm_macs()  { driver_vm_macs "$@"; }
  HV_LOADED="$name"
}

detect_driver() {
  [[ -n "$HV_LOADED" ]] && return 0
  # Config override
  if [[ -n "${HYPERVISOR:-}" ]]; then
    load_driver "$HYPERVISOR"
    return $?
  fi
  # Auto-detect: try each driver
  local drv name
  for drv in "$SCRIPT_DIR"/drivers/*.sh; do
    [[ -f "$drv" ]] || continue
    name="$(basename "$drv" .sh)"
    (source "$drv"; driver_detect) && { load_driver "$name"; return 0; }
  done
  return 1
}

require_driver() {
  [[ -n "$HV_LOADED" ]] && return 0
  echo "error: no hypervisor driver detected (install virsh/lxc/xl or set HYPERVISOR in config)" >&2
  exit 1
}

# ---------------------------------------------------------------------------
# Preflight checks
# ---------------------------------------------------------------------------

preflight() {
  have_cmd nft    || { echo "error: nft not found" >&2; exit 1; }
  have_cmd bridge || { echo "error: bridge (iproute2) not found" >&2; exit 1; }
  have_cmd ip     || { echo "error: ip not found" >&2; exit 1; }

  ip link show "$BRIDGE" >/dev/null 2>&1 \
    || { echo "error: bridge '$BRIDGE' not found" >&2; exit 1; }

  local upl vm
  upl="$(uplink_ports || true)"
  [[ -n "$upl" ]] \
    || { echo "error: no uplink ports on '$BRIDGE' (set UPLINK_REGEX in config)" >&2; exit 1; }

  vm="$(vm_ports || true)"
  [[ -n "$vm" ]] \
    || echo "warn: no VM ports on '$BRIDGE'; applying empty ruleset" >&2
}

# ---------------------------------------------------------------------------
# nftables ruleset generation
# ---------------------------------------------------------------------------

generate_ruleset() {
  local tmp="$1"
  local upl vm

  upl="$(uplink_ports)"
  vm="$(vm_ports || true)"

  # The ensure-exists / delete / recreate pattern makes the entire load
  # atomic: nft -f applies the file as a single transaction so there is
  # never a window where the table is absent.
  {
    echo "table bridge $TABLE { }"
    echo "delete table bridge $TABLE"
    echo "table bridge $TABLE {"
    echo "  set $SET_WL       { type ether_addr;   }"
    echo "  set $SET_PORTS    { type inet_service;  }"
    echo "  set $SET_VMPORTS  { type ifname;        }"
    echo "  set $SET_UPLINKS  { type ifname;        }"
    echo "  chain $CHAIN {"
    echo "    type filter hook forward priority -200; policy accept;"

    # Whitelisted MACs bypass the block (IPv4 + IPv6)
    echo "    iifname @$SET_VMPORTS oifname @$SET_UPLINKS ether type ip  ether saddr @$SET_WL tcp dport @$SET_PORTS accept"
    echo "    iifname @$SET_VMPORTS oifname @$SET_UPLINKS ether type ip6 ether saddr @$SET_WL tcp dport @$SET_PORTS accept"

    # Log and drop must be separate rules.  nftables "limit" is a match
    # expression: packets exceeding the rate skip the rule entirely.  If
    # log+drop were combined in one limited rule, excess packets would
    # fall through to the chain policy (accept).
    if [[ "${LOG_DROPS}" == "1" ]]; then
      echo "    iifname @$SET_VMPORTS oifname @$SET_UPLINKS ether type ip  tcp dport @$SET_PORTS limit rate ${LOG_RATE} burst ${LOG_BURST} packets log prefix \"SMTPGATE4 \" flags all"
      echo "    iifname @$SET_VMPORTS oifname @$SET_UPLINKS ether type ip6 tcp dport @$SET_PORTS limit rate ${LOG_RATE} burst ${LOG_BURST} packets log prefix \"SMTPGATE6 \" flags all"
    fi
    echo "    iifname @$SET_VMPORTS oifname @$SET_UPLINKS ether type ip  tcp dport @$SET_PORTS counter drop"
    echo "    iifname @$SET_VMPORTS oifname @$SET_UPLINKS ether type ip6 tcp dport @$SET_PORTS counter drop"

    echo "  }"
    echo "}"
  } > "$tmp"

  # Populate sets
  {
    echo "flush set bridge $TABLE $SET_PORTS"
    while read -r p; do
      [[ -n "$p" ]] || continue
      echo "add element bridge $TABLE $SET_PORTS { $p }"
    done < <(parse_ports)

    echo "flush set bridge $TABLE $SET_UPLINKS"
    while read -r p; do
      [[ -n "$p" ]] || continue
      echo "add element bridge $TABLE $SET_UPLINKS { \"$p\" }"
    done <<< "$upl"

    echo "flush set bridge $TABLE $SET_VMPORTS"
    while read -r p; do
      [[ -n "$p" ]] || continue
      echo "add element bridge $TABLE $SET_VMPORTS { \"$p\" }"
    done <<< "$vm"

    echo "flush set bridge $TABLE $SET_WL"
    awk -F',' '
      BEGIN{IGNORECASE=1}
      $1 ~ /^#/ {next}
      NF >= 2 {
        gsub(/^[ \t]+|[ \t]+$/, "", $2);
        if ($2 ~ /^([0-9a-f]{2}:){5}[0-9a-f]{2}$/) print tolower($2);
      }' "$WL_FILE" | while read -r mac; do
        [[ -n "$mac" ]] || continue
        echo "add element bridge $TABLE $SET_WL { $mac }"
      done
  } >> "$tmp"
}

# ---------------------------------------------------------------------------
# Commands
# ---------------------------------------------------------------------------

cmd_apply() {
  load_conf
  ensure_dirs
  preflight

  _TMP="$(mktemp /tmp/smtp-gate.XXXXXX.nft)"
  trap 'rm -f "${_TMP:-}"' EXIT

  generate_ruleset "$_TMP"

  nft -c -f "$_TMP"   # validate (dry-run); on failure nothing changes
  nft -f "$_TMP"       # atomic load

  echo "ok: applied bridge=$BRIDGE ports=$BLOCKED_PORTS"
}

cmd_status() {
  load_conf
  ensure_dirs

  # Active or inactive?
  if nft list table bridge "$TABLE" >/dev/null 2>&1; then
    echo "Status:     active"
  else
    echo "Status:     inactive (run 'smtp-gate apply')"
  fi

  echo "Bridge:     $BRIDGE"
  echo "Ports:      $BLOCKED_PORTS"
  echo "Hypervisor: ${HV_LOADED:-none}"
  echo

  # Whitelisted VMs from CSV
  local count=0
  echo "Whitelisted:"
  while IFS=',' read -r name mac added_at added_by reason; do
    [[ "$name" =~ ^# ]] && continue
    [[ -n "$name" ]] || continue
    mac="$(echo "$mac" | tr -d ' \t')"
    [[ "$mac" =~ ^([0-9a-fA-F]{2}:){5}[0-9a-fA-F]{2}$ ]] || continue
    printf "  %-24s %s\n" "$name" "$mac"
    count=$((count + 1))
  done < "$WL_FILE"
  [[ "$count" -gt 0 ]] || echo "  (none)"
}

cmd_debug() {
  load_conf
  ensure_dirs

  echo "Config:"
  echo "  CONF_FILE=$CONF_FILE"
  echo "  WL_FILE=$WL_FILE"
  echo "  BRIDGE=$BRIDGE"
  echo "  BLOCKED_PORTS=$BLOCKED_PORTS"
  echo "  LOG_DROPS=$LOG_DROPS"
  echo "  LOG_RATE=$LOG_RATE"
  echo "  LOG_BURST=$LOG_BURST"
  echo "  UPLINK_REGEX=${UPLINK_REGEX:-<default>}"
  echo "  HYPERVISOR=${HV_LOADED:-<none detected>}"
  echo
  echo "Bridge ports ($BRIDGE):"
  bridge_ports | sed 's/^/  - /' || echo "  (none)"
  echo
  echo "Uplinks:"
  uplink_ports | sed 's/^/  - /' || echo "  (none)"
  echo
  echo "VM ports:"
  vm_ports | sed 's/^/  - /' || echo "  (none)"
  echo
  echo "nft table:"
  nft list table bridge "$TABLE" 2>/dev/null || echo "  (not loaded)"
}

cmd_disable() {
  nft delete table bridge "$TABLE" >/dev/null 2>&1 || true
  echo "ok: disabled -- removed table bridge $TABLE"
}

cmd_ports_set() {
  local ports="${1:-}"
  [[ -n "$ports" ]] || { echo "error: provide ports like '25,465,587'" >&2; exit 1; }
  mkdir -p "$CONF_DIR"
  if [[ -f "$CONF_FILE" ]] && grep -q '^BLOCKED_PORTS=' "$CONF_FILE"; then
    sed -i "s/^BLOCKED_PORTS=.*/BLOCKED_PORTS=\"${ports}\"/" "$CONF_FILE"
  else
    echo "BLOCKED_PORTS=\"${ports}\"" >> "$CONF_FILE"
  fi
  echo "ok: set BLOCKED_PORTS=$ports (run apply to activate)"
}

cmd_add_vm() {
  load_conf
  ensure_dirs
  require_driver

  local vm="${1:-}"
  local reason="${2:-manual}"
  [[ -n "$vm" ]] || { echo "error: vm name required" >&2; exit 1; }

  local macs now user
  macs="$(hv_vm_macs "$vm" || true)"
  [[ -n "$macs" ]] || { echo "error: no bridged MACs found for vm '$vm'" >&2; exit 1; }

  now="$(date -Is)"
  user="${SUDO_USER:-root}"

  while read -r mac; do
    [[ -n "$mac" ]] || continue
    echo "${vm},${mac},${now},${user},${reason}" >> "$WL_FILE"
    echo "ok: whitelisted $vm ($mac)"
  done <<< "$macs"

  cmd_apply >/dev/null
  echo "ok: applied"
}

cmd_add_mac() {
  load_conf
  ensure_dirs

  local mac="${1:-}"
  local label="${2:-manual}"
  [[ -n "$mac" ]] || { echo "error: mac required" >&2; exit 1; }
  [[ "$mac" =~ ^([0-9A-Fa-f]{2}:){5}[0-9A-Fa-f]{2}$ ]] \
    || { echo "error: invalid mac format" >&2; exit 1; }

  local now user
  now="$(date -Is)"
  user="${SUDO_USER:-root}"
  echo "${label},$(echo "$mac" | tr 'A-F' 'a-f'),${now},${user},manual-mac" >> "$WL_FILE"
  echo "ok: whitelisted mac $mac (label=$label)"

  cmd_apply >/dev/null
  echo "ok: applied"
}

cmd_del_vm() {
  load_conf
  ensure_dirs

  local vm="${1:-}"
  [[ -n "$vm" ]] || { echo "error: vm name required" >&2; exit 1; }

  local tmp
  tmp="$(mktemp)"
  awk -F',' -v vm="$vm" '
    BEGIN{IGNORECASE=1}
    $1 ~ /^#/ {print; next}
    {gsub(/^[ \t]+|[ \t]+$/, "", $1); if ($1!=vm) print}
  ' "$WL_FILE" > "$tmp"
  mv "$tmp" "$WL_FILE"
  echo "ok: removed whitelist entries for vm $vm"

  cmd_apply >/dev/null
  echo "ok: applied"
}

cmd_del_mac() {
  load_conf
  ensure_dirs

  local mac="${1:-}"
  [[ -n "$mac" ]] || { echo "error: mac required" >&2; exit 1; }
  mac="$(echo "$mac" | tr 'A-F' 'a-f')"

  local tmp
  tmp="$(mktemp)"
  awk -F',' -v mac="$mac" '
    $1 ~ /^#/ {print; next}
    {gsub(/^[ \t]+|[ \t]+$/, "", $2); if (tolower($2)!=mac) print}
  ' "$WL_FILE" > "$tmp"
  mv "$tmp" "$WL_FILE"
  echo "ok: removed whitelist entries for mac $mac"

  cmd_apply >/dev/null
  echo "ok: applied"
}

cmd_list() {
  ensure_dirs
  if have_cmd column; then
    column -s, -t "$WL_FILE"
  else
    cat "$WL_FILE"
  fi
}

cmd_whitelist() {
  load_conf
  ensure_dirs
  require_driver

  # Build set of whitelisted MACs from CSV
  local -A wl_macs
  while IFS=',' read -r name mac rest; do
    [[ "$name" =~ ^# ]] && continue
    mac="$(echo "$mac" | tr -d ' \t' | tr 'A-F' 'a-f')"
    [[ "$mac" =~ ^([0-9a-f]{2}:){5}[0-9a-f]{2}$ ]] || continue
    wl_macs["$mac"]=1
  done < "$WL_FILE"

  # Collect VM entries: index status vmname mac
  local -a entries=()
  local idx=0 vm mac status
  while read -r vm; do
    [[ -n "$vm" ]] || continue
    while read -r mac; do
      [[ -n "$mac" ]] || continue
      mac="$(echo "$mac" | tr 'A-F' 'a-f')"
      if [[ -n "${wl_macs[$mac]+x}" ]]; then
        status="whitelisted"
      else
        status="blocked"
      fi
      idx=$((idx + 1))
      entries+=("$idx $status $vm $mac")
    done < <(hv_vm_macs "$vm" 2>/dev/null || true)
  done < <(hv_list_vms 2>/dev/null)

  if [[ ${#entries[@]} -eq 0 ]]; then
    echo "No VMs found."
    return 0
  fi

  # Print numbered list
  printf "\n"
  printf "  %-4s %-15s %-24s %s\n" "#" "STATUS" "VM" "MAC"
  printf "  %-4s %-15s %-24s %s\n" "---" "-------------" "----------------------" "-----------------"
  local entry num st nm mc
  for entry in "${entries[@]}"; do
    read -r num st nm mc <<< "$entry"
    if [[ "$st" == "whitelisted" ]]; then
      printf "  %-4s [whitelisted]   %-24s %s\n" "$num" "$nm" "$mc"
    else
      printf "  %-4s [blocked]       %-24s %s\n" "$num" "$nm" "$mc"
    fi
  done
  printf "\n"

  # Prompt -- select numbers to toggle
  local selection
  read -rp "Toggle numbers (comma-separated), or 'q' to quit: " selection
  [[ "$selection" != "q" && "$selection" != "Q" ]] || return 0

  local now user changed=0
  now="$(date -Is)"
  user="${SUDO_USER:-root}"

  local sel
  for sel in $(echo "$selection" | tr ',' ' '); do
    sel="$(echo "$sel" | tr -d ' ')"
    [[ "$sel" =~ ^[0-9]+$ ]] || continue
    for entry in "${entries[@]}"; do
      read -r num st nm mc <<< "$entry"
      [[ "$num" == "$sel" ]] || continue
      if [[ "$st" == "blocked" ]]; then
        # Add to whitelist
        echo "${nm},${mc},${now},${user},whitelist-cmd" >> "$WL_FILE"
        echo "ok: whitelisted $nm ($mc)"
        changed=$((changed + 1))
      else
        # Remove from whitelist -- delete lines matching this MAC
        local tmp
        tmp="$(mktemp)"
        awk -F',' -v mac="$mc" '
          $1 ~ /^#/ {print; next}
          {gsub(/^[ \t]+|[ \t]+$/, "", $2); if (tolower($2)!=mac) print}
        ' "$WL_FILE" > "$tmp"
        mv "$tmp" "$WL_FILE"
        echo "ok: removed $nm ($mc)"
        changed=$((changed + 1))
      fi
    done
  done

  if [[ "$changed" -gt 0 ]]; then
    cmd_apply >/dev/null
    echo "ok: applied"
  else
    echo "No changes made."
  fi
}

usage() {
  cat <<EOF
Usage: smtp-gate <command> [args]

Commands:
  status                             Show active/inactive state and whitelisted VMs
  apply                              (Re)apply nftables rules
  disable                            Remove all rules (unblock everything)
  whitelist                          Interactive VM picker
  add-vm  <vmname> [reason]          Whitelist a VM by name
  del-vm  <vmname>                   Remove a VM from the whitelist
  add-mac <aa:bb:cc:dd:ee:ff> [label] Whitelist a MAC address directly
  del-mac <aa:bb:cc:dd:ee:ff>        Remove a MAC from the whitelist
  ports-set "25,465,587"             Change blocked ports
  list                               Show raw whitelist CSV
  debug                              Show bridge ports, nft table, and full config
EOF
}

# ---------------------------------------------------------------------------
# Main
# ---------------------------------------------------------------------------

require_root
load_conf
detect_driver || true
cmd="${1:-}"; shift || true

case "$cmd" in
  status)    cmd_status ;;
  apply)     cmd_apply ;;
  disable)   cmd_disable ;;
  whitelist) cmd_whitelist ;;
  add-vm)    cmd_add_vm "${1:-}" "${2:-manual}" ;;
  del-vm)    cmd_del_vm "${1:-}" ;;
  add-mac)   cmd_add_mac "${1:-}" "${2:-manual}" ;;
  del-mac)   cmd_del_mac "${1:-}" ;;
  ports-set) cmd_ports_set "${1:-}" ;;
  list)      cmd_list ;;
  debug)     cmd_debug ;;
  *)         usage; exit 1 ;;
esac
